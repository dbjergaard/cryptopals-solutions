#!/usr/bin/env ruby 
require 'curb'
require 'crypto_tools'
require 'block_crypto'
require 'openssl'

def challenge9
  if Converters.str_to_hex("YELLOW SUBMARINE".pkcs7pad(20)).slice(32,8)!="04040404"
    raise "Error padding string to 20 bytes!"
  else
    puts "Challenge 9 passed!"
  end
end
def challenge10
  cipher_http = Curl.get("http://cryptopals.com/static/challenge-data/10.txt")
  key="YELLOW SUBMARINE"
  iv=Converters.hex_to_bytes("00000000000000000000000000000000")
  clear_text=BlockCrypto.aes_cbc_decrypt(Base64.decode64(cipher_http.body_str),key,iv)
  if clear_text.split(/\n/)[-1] != "Play that funky music "
    raise "Challenge 10 failed!"
  else
    puts "Challenge 10 passed!"
  end
end
def challenge11
  ecb_times=0
  ntimes=1000
  ntimes.times do |i| 
    ecb_cipher_text=CryptoTools.detect_aes_ecb(BlockCrypto.encryption_oracle("A"*256))
    if ecb_cipher_text.length > 0
      ecb_times+=1
    end
  end
  detected_frac=Float(ecb_times)/ntimes
  if (detected_frac-0.5).abs < 0.1
    puts "Challenge 11 passed!"
  else
    raise sprintf "Challenge 11 failed, fraction detected %.3g %% of %d",detected_frac,ntimes
  end
end
def challenge12
  unknown_string=Base64.decode64(["Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg",
                                  "aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq",
                                  "dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg",
                                  "YnkK"].join)
  # unknown_string="Yellow Submarines are cool"
  puts Base64.encode64("Yellow Submarines are cool")
  # 1. Determine block size and secret length
  secret_key=BlockCrypto.random_byte_string(16)
  init_len=BlockCrypto.AES_128_ECB(unknown_string,secret_key).length
  block_size=0
  secret_len=0
  17.times do |i| 
    len=BlockCrypto.AES_128_ECB("A"*i+unknown_string,secret_key).length
    if len > init_len
      secret_len=init_len-i
      block_size=len-init_len
      break
    end
  end
  printf "Step 1: Block size detected, length %d\n",block_size
  # 2. Detect ECB
  l=CryptoTools.detect_aes_ecb(BlockCrypto.AES_128_ECB("A"*256+unknown_string,secret_key))
  if l!=""
    puts "Step 2: Detected ECB"
  else
    raise "Did not detect ECB in challenge 12"
  end
  # 3. Make input block that is 1 byte short
  # 4. Create a list of ciphertexts from all possible last bytes
  # 5. Match the output of the 1 byte short to the list created in 4
  # for each byte
  #    3. make input block
  #    4. build dictionary of byte combinations
  #    5. check for byte in dictionary
  #    5a. add byte to decoded string
  decoded_str=""
  input_len=(init_len-1)
  # puts secret_len, unknown_string.length
  secret_len.times do 
    input_block="A"*input_len+decoded_str
    printf "%s:%d\n",input_block,input_block.length
    block_dictionary=Hash.new("")
    32.upto(126) do |c| 
      # puts input_block.slice(-block_size+1,block_size-1)+c.chr
      block_dictionary[BlockCrypto.AES_128_ECB(input_block.slice(-block_size+1,block_size-1)+c.chr,secret_key).slice(0,block_size)]=c.chr.to_s
    end
    cipher_text=BlockCrypto.AES_128_ECB("A"*input_len+unknown_string,secret_key)
    detected_byte=block_dictionary[cipher_text.slice(((init_len/block_size)-1)*block_size,block_size)]
    if detected_byte != ""
      decoded_str+=detected_byte
    end
    input_len=(init_len-decoded_str.length-1)
  end
  puts decoded_str
  # 6. Repeat for the next byte
end
def run_challenges
  challenge9
  challenge10
  challenge11
  challenge12
end

challenge12
# run_challenges

