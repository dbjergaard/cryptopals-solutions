#!/usr/bin/env ruby 
require 'openssl'
require 'block_crypto'
require 'string_utils'
require 'pubkey'
require 'dh_clients'
require 'converters'
require 'securerandom'
NIST_PRIME=0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff
def challenge33
  
  #Alice
  p=NIST_PRIME
  g=2
  alice = DiffieHellman.new(p,g)
  bob = DiffieHellman.new(p,g)
  bob_s=bob.session(alice.pub_key)
  alice_s=alice.session(bob.pub_key)

  if alice_s != bob_s
    raise "Challenge 33 failed!" 
  else
    puts "Challenge 33 passed!"
  end
end
def challenge34
  message="Alice was beginning to get very tired of sitting by her sister on the
bank, and of having nothing to do: once or twice she had peeped into the
book her sister was reading, but it had no pictures or conversations in
it, 'and what is the use of a book,' thought Alice 'without pictures or
conversation?'".split("\n")
  #this class structure was inspired from: http://blog.sysca.co.uk/2015/03/matasano-cryptopalschallenges-3334.html
  alice = DiffieHellmanPeer.new("alice",NIST_PRIME,2)
  bob = DiffieHellmanEcho.new("bob",37,2)
  alice.connect(bob)
  bob.connect(alice)
  alice.key_exchange
  
  puts alice
  puts bob
  if alice.aes_key!=bob.aes_key
    raise "Diffie Hellman key exchange error, Challenge 34 failed!"
  end
  alice.close_connection
  bob.close_connection
  mallory = DiffieHellmanMITM.new("mallory",NIST_PRIME,2)

  alice.connect(mallory)
  mallory.connect(alice)
  bob.connect(mallory)
  mallory.connect(bob)
  alice.key_exchange
  mallory.key_exchange
  
  message.each do |m|
    alice.send(m)
  end
  if mallory.aes_key != alice.aes_key
    raise "Challenge 34 failed, mallory's key doesn't match alice's"
  end
  if mallory.aes_key != bob.aes_key
    raise "Challenge 34 failed, mallory's key doesn't match bob's"
  end
  puts "Challenge 34 passed!"
end

class DHGroups < DiffieHellmanPeer
  def key_exchange
    @peer.handshake("#{@dh_key.P},#{@dh_key.G}")
  end
  def handshake(dh_params)
    params = dh_params.split(",")
    if params.length==2
      # puts "#{@name} received #{dh_params.inspect}"
      @dh_key = DiffieHellman.new(params[0].to_i,params[1].to_i)
      @peer.handshake([6].pack("C*"))
    elsif params[0]==[6].pack("C*")
      # puts "#{@name} received #{dh_params.inspect}"
      @peer.handshake("#{@dh_key.pub_key}")
    else
      # puts "#{@name} received #{dh_params.inspect}"
      @aes_key=@dh_key.sha1_session(dh_params.to_i)
      if @peer.aes_key==nil
        @peer.handshake("#{@dh_key.pub_key}")
      end
      # puts "#{@name}'s shared aes key: #{@aes_key.unpack("H*")[0]}"
    end
  end
end
class DHGroupsMITM < DHGroups
  
  def initialize(name,p,g)
    @name = name
    @dh_key = DiffieHellman.new(p,g)
    @aes_key = nil#Digest::SHA1.digest([g%p].pack("C*"))
    @alice = nil
    @bob = nil
  end
  def handshake(dh_params)
    params=dh_params.split(",")
    if params.length == 2
      @alice.handshake("#{@dh_key.P},#{@dh_key.G}")
      @bob.handshake("#{@dh_key.P},#{@dh_key.G}")
    elsif params[0]==[6].pack("C*")
      @alice.handshake("#{@dh_key.pub_key}")
      @bob.handshake("#{@dh_key.pub_key}")
    else
      @aes_key = @dh_key.sha1_session(dh_params.to_i)
    end
  end
  def connect(peer)
    if @alice == nil
      @alice = peer
    else
      @bob = peer
    end
  end
  def to_s
    "name: #{@name}, aes_key: #{@aes_key.unpack("H*")[0]}\n\talice: #{@alice}\n\tbob: #{@bob}"
  end
end
def malicious_g(g)
  alice = DHGroups.new("alice",NIST_PRIME,2)
  bob = DHGroups.new("bob",37,5)
  
  mallory = DHGroupsMITM.new("mallory",NIST_PRIME,g)
  alice.connect(mallory)
  mallory.connect(alice)
  bob.connect(mallory)
  mallory.connect(bob)
  alice.key_exchange
  if mallory.aes_key!=alice.aes_key
    puts mallory.aes_key.unpack("H*")[0]
    puts alice.aes_key.unpack("H*")[0]
    raise "Challenge 35: Mallory's key does not match alice's"
  end
  if mallory.aes_key!=bob.aes_key
    puts mallory.aes_key.unpack("H*")[0]
    puts bob.aes_key.unpack("H*")[0]
    raise "Challenge 35: Mallory's key does not match bob's"
  end
end
def challenge35
  malicious_g(1)
  malicious_g(NIST_PRIME)
  malicious_g(NIST_PRIME-1)
  puts "Challenge 35 passed!"
end
class SRPServer
  def initialize()
    @k=3
    @dh_key = DiffieHellman.new(NIST_PRIME,2)
    @client = nil
    @v = nil
    @salt=nil
    @pubA = nil
  end
  def register(client,email,password)
    @client = client
    client.connect(self)
    @salt = SecureRandom.random_number(2**256)
    x = Digest::SHA2.digest("#{@salt}#{password}").unpack("H*")[0].to_i(16)
    g = @dh_key.G
    p = @dh_key.P
    @v=g.modexp(x,p)
    x=0
  end
  def connect(client)
    @client = client
  end
  def login(email,pub_key)
    @pubA = pub_key
    @client.verify(@salt,@k*@v + @dh_key.pub_key)
  end
  def verify(key)
    u = Digest::SHA2.digest("#{@pubA}#{@k*@v+@dh_key.pub_key}").unpack("H*")[0].to_i(16)
    s = (@pubA*@v.modexp(u,@dh_key.P)).modexp(@dh_key.a,@dh_key.P)
    k = Digest::SHA2.digest("#{s}")
    hmac_key = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha256'),k,[@salt.to_s(16)].pack("H*"))
    return hmac_key==key
  end
end
class SRPClient
  def initialize(email,password)
    @email=email
    @password= password
    @k=3
    @dh_key = DiffieHellman.new(NIST_PRIME,2)
    @server = nil
  end
  def connect(server)
    @server = server
  end
  def login()
    @server.login(@email,@dh_key.pub_key)
  end
  def verify(salt,pubB)
    u = Digest::SHA2.digest("#{@dh_key.pub_key}#{pubB}").unpack("H*")[0].to_i(16)
    x = Digest::SHA2.digest("#{salt}#{@password}").unpack("H*")[0].to_i(16)
    a=@dh_key.a
    n=@dh_key.P
    g=@dh_key.G
    s = (pubB - @k*g.modexp(x,n) ).modexp(a+u*x,n)
    k = Digest::SHA2.digest("#{s}")
    hmac_key = OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha256'),k,[salt.to_s(16)].pack("H*"))
    if @server.verify(hmac_key)
      puts "Logged in!"
    else
      raise "Secure Remote Password authetication failed"
    end
  end
end
def challenge36
  server = SRPServer.new
  client = SRPClient.new("foo@bar.com","password")
  client.connect(server)
  server.register(client,"foo@bar.com","password")
  # begin 
    client.login
  # rescue Exception => e
  #   puts "Login failed! #{e.message}"
  #   raise "Challenge 36 failed!"
  # end
  puts "Challenge 36 passed!"
end
def run_challenges
  # challenge33
  # challenge34
  # challenge35
  challenge36
end
run_challenges
